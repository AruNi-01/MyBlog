<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.48">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="/img/logo/favicon-32_32.png"><link rel="manifest" href="/manifest.webmanifest"><meta name="application-name" content="AruNi"><meta name="apple-mobile-web-app-title" content="AruNi"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/img/logo/apple-touch-icon.png"><meta name="theme-color" content="#1e2124"><meta name="msapplication-TileColor" content="#1e2124"><title>Java 内存模型 | AruNi</title><meta name="description" content="AruNi">
    <link rel="modulepreload" href="/assets/app.307f64f3.js"><link rel="modulepreload" href="/assets/2022-12-16-Java 内存模型.html.d95e1f9b.js"><link rel="modulepreload" href="/assets/2022-12-16-Java 内存模型.html.a58acf00.js"><link rel="prefetch" href="/assets/index.html.5d70a31e.js"><link rel="prefetch" href="/assets/2022-08-16-Hello_VuePress.html.58bc7bfa.js"><link rel="prefetch" href="/assets/2022-08-21-LeetCode 第 307 场周赛.html.6baebe90.js"><link rel="prefetch" href="/assets/2022-10-31-仿牛客项目总结.html.81b01d58.js"><link rel="prefetch" href="/assets/2022-12-1-ThreadLocal 详解.html.8fef6b6a.js"><link rel="prefetch" href="/assets/2022-12-12-什么是 HTTP.html.ed3e4aca.js"><link rel="prefetch" href="/assets/2022-12-17-Object 类.html.d5303a2c.js"><link rel="prefetch" href="/assets/2022-12-18-String 类.html.e7e3b4ae.js"><link rel="prefetch" href="/assets/2022-12-27-volatile 详解.html.023ef2e3.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.de26035a.js"><link rel="prefetch" href="/assets/index.html.4a704eac.js"><link rel="prefetch" href="/assets/index.html.c92bc6f3.js"><link rel="prefetch" href="/assets/index.html.5abce942.js"><link rel="prefetch" href="/assets/index.html.cdfaefff.js"><link rel="prefetch" href="/assets/index.html.bb24b47e.js"><link rel="prefetch" href="/assets/index.html.122e117f.js"><link rel="prefetch" href="/assets/index.html.316d8e9c.js"><link rel="prefetch" href="/assets/index.html.b5449332.js"><link rel="prefetch" href="/assets/index.html.b0cee4e0.js"><link rel="prefetch" href="/assets/index.html.61779abc.js"><link rel="prefetch" href="/assets/index.html.deae5fb3.js"><link rel="prefetch" href="/assets/index.html.27eb05c4.js"><link rel="prefetch" href="/assets/2022-08-16-Hello_VuePress.html.139bd300.js"><link rel="prefetch" href="/assets/2022-08-21-LeetCode 第 307 场周赛.html.efe8a7eb.js"><link rel="prefetch" href="/assets/2022-10-31-仿牛客项目总结.html.30924a35.js"><link rel="prefetch" href="/assets/2022-12-1-ThreadLocal 详解.html.76ea835a.js"><link rel="prefetch" href="/assets/2022-12-12-什么是 HTTP.html.d8df10a0.js"><link rel="prefetch" href="/assets/2022-12-17-Object 类.html.4a31744f.js"><link rel="prefetch" href="/assets/2022-12-18-String 类.html.90cd66d4.js"><link rel="prefetch" href="/assets/2022-12-27-volatile 详解.html.a1a1eed1.js"><link rel="prefetch" href="/assets/404.html.81dcb45e.js"><link rel="prefetch" href="/assets/index.html.3a540468.js"><link rel="prefetch" href="/assets/index.html.c97e9f79.js"><link rel="prefetch" href="/assets/index.html.9968968c.js"><link rel="prefetch" href="/assets/index.html.5730905c.js"><link rel="prefetch" href="/assets/index.html.d985db7f.js"><link rel="prefetch" href="/assets/index.html.66c10b26.js"><link rel="prefetch" href="/assets/index.html.dda9f061.js"><link rel="prefetch" href="/assets/index.html.e47c2733.js"><link rel="prefetch" href="/assets/index.html.6bb04414.js"><link rel="prefetch" href="/assets/index.html.5f783c02.js"><link rel="prefetch" href="/assets/index.html.7061b670.js"><link rel="prefetch" href="/assets/index.html.35811ede.js"><link rel="prefetch" href="/assets/404.a2d8fd28.js"><link rel="prefetch" href="/assets/HomePage.8c14bba1.js"><link rel="prefetch" href="/assets/Layout.a7ff88f6.js"><link rel="prefetch" href="/assets/Links.06865639.js"><link rel="prefetch" href="/assets/Post.0a455746.js"><link rel="prefetch" href="/assets/Tags.0cd1c0a4.js"><link rel="prefetch" href="/assets/index.4f5d4e06.js">
    <link rel="stylesheet" href="/assets/style.f603b422.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(https://aruni-01-github-io.oss-cn-beijing.aliyuncs.com/posts/JMM.png);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">Java 并发</span><span class="article-tag">Java</span><!--]--></div><h1 class="article-title">Java 内存模型</h1><p class="article-subtitle">揭开 JMM 神秘的面纱「Tag - Java 并发」</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>AruNi_Lu</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-12-16</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>24 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><!--]--><div><p>Java 并发系列 —— Java 内存模型</p><div class="custom-container tip"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M297.6 258.73H296c-59.47.87-110.69 51.45-111.83 110.43-.626 36.485 16.525 71.085 45.94 92.68 17.86 13.18 29.88 33.56 33.77 56.42h67.62c4-22.82 16.13-43.3 34.16-56.74 28.589-21.097 45.496-54.587 45.496-90.118 0-30.03-12.078-58.833-33.496-79.882a113.133 113.133 0 0 0-80.06-32.79ZM265.19 550.7v26.6c0 4.84 1.17 6.43 1.17 6.43l63.72-.59V550.7h-64.89Z" style="fill:#48b884;fill-rule:nonzero;" transform="matrix(.042 0 0 .042 0 -5.178)"></path><path d="M297.64 123.3C133.26 123.3 0 256.56 0 420.94s133.26 297.63 297.64 297.63 297.63-133.25 297.63-297.63S462 123.3 297.64 123.3ZM385 487.57c-14.11 10.48-22.51 28.09-22.51 47.14v48.43c-.016 17.792-14.648 32.428-32.44 32.45h-64.86c-15.6 0-32.44-12-32.44-38.29v-42.82c0-19-8.21-36.4-21.93-46.52-37.882-27.85-59.959-72.44-59.14-119.45 1.46-77.24 66-141.09 143.81-142.22 38.87.19 76.89 14.37 105 42.11a143.764 143.764 0 0 1 43.14 103c-.159 45.761-21.911 88.86-58.63 116.17Z" style="fill:#48b884;fill-rule:nonzero;" transform="matrix(.042 0 0 .042 0 -5.178)"></path></svg><p class="custom-container-title">本文内容：</p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_1-java-内存模型基础" class="router-link-active router-link-exact-active">1. Java 内存模型基础</a><ul><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_1-1-为什么需要并发" class="router-link-active router-link-exact-active">1.1 为什么需要并发</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_1-2-并发编程的问题" class="router-link-active router-link-exact-active">1.2 并发编程的问题</a></li></ul></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_2-java-内存模型是什么" class="router-link-active router-link-exact-active">2. Java 内存模型是什么</a><ul><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_2-1-jmm-的抽象结构" class="router-link-active router-link-exact-active">2.1 JMM 的抽象结构</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_2-2-jmm-中的-8-个原子操作" class="router-link-active router-link-exact-active">2.2 JMM 中的 8 个原子操作</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_2-3-可见性、有序性问题" class="router-link-active router-link-exact-active">2.3 可见性、有序性问题</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_2-4-重排序问题" class="router-link-active router-link-exact-active">2.4 重排序问题</a></li></ul></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_3-happens-before-规则" class="router-link-active router-link-exact-active">3. Happens-Before 规则</a><ul><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_3-1-什么是-happens-before" class="router-link-active router-link-exact-active">3.1 什么是 Happens-Before</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_3-2-jmm-的设计" class="router-link-active router-link-exact-active">3.2 JMM 的设计</a></li></ul></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_4-内存屏障" class="router-link-active router-link-exact-active">4. 内存屏障</a><ul><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_4-1-什么是内存屏障" class="router-link-active router-link-exact-active">4.1 什么是内存屏障</a></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_4-2-jmm-提供的内存屏障" class="router-link-active router-link-exact-active">4.2 JMM 提供的内存屏障</a></li></ul></li><li><a aria-current="page" href="/posts/2022-12-16-Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_5-参考文章" class="router-link-active router-link-exact-active">5. 参考文章</a></li></ul></nav></div><h2 id="_1-java-内存模型基础" tabindex="-1"><a class="header-anchor" href="#_1-java-内存模型基础" aria-hidden="true">#</a> 1. Java 内存模型基础</h2><h3 id="_1-1-为什么需要并发" tabindex="-1"><a class="header-anchor" href="#_1-1-为什么需要并发" aria-hidden="true">#</a> 1.1 为什么需要并发</h3><p>我们为什么需要并发？并发编程 Bug 的源头是什么？如何解决并发问题？分享一张图告诉大家：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212142038920.png" alt="image-20221214203801222"></p><p>可见，Java 内存模型（JMM）在并发中是一个非常重要的角色，理解它，将让你在学习并发编程的过程中更加得心应手。</p><h3 id="_1-2-并发编程的问题" tabindex="-1"><a class="header-anchor" href="#_1-2-并发编程的问题" aria-hidden="true">#</a> 1.2 并发编程的问题</h3><p>在并发编程中，需要处理两个关键的问题：</p><ul><li>线程之间如何 <strong>通信</strong>；</li><li>线程之间如何 <strong>同步</strong>；</li></ul><div class="custom-container info"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M13 1.188C6.477 1.188 1.188 6.477 1.188 13S6.477 24.813 13 24.813 24.813 19.523 24.813 13c0-6.523-5.29-11.812-11.813-11.812Zm2.459 18.307c-.608.24-1.092.422-1.455.548a3.838 3.838 0 0 1-1.262.189c-.736 0-1.309-.18-1.717-.539a1.74 1.74 0 0 1-.611-1.367c0-.215.015-.435.045-.659a8.23 8.23 0 0 1 .147-.759l.761-2.688c.067-.258.125-.503.171-.731.046-.23.068-.441.068-.633 0-.342-.071-.582-.212-.717-.143-.135-.412-.201-.813-.201-.196 0-.398.029-.605.09-.205.063-.383.12-.529.176l.201-.828c.498-.203.975-.377 1.43-.521a4.225 4.225 0 0 1 1.29-.218c.731 0 1.295.178 1.692.53.395.353.594.812.594 1.376 0 .117-.014.323-.041.617a4.129 4.129 0 0 1-.152.811l-.757 2.68a7.582 7.582 0 0 0-.167.736 3.892 3.892 0 0 0-.073.626c0 .356.079.599.239.728.158.129.435.194.827.194.185 0 .392-.033.626-.097.232-.064.4-.121.506-.17l-.203.827Zm-.134-10.878a1.807 1.807 0 0 1-1.275.492c-.496 0-.924-.164-1.28-.492a1.57 1.57 0 0 1-.533-1.193c0-.465.18-.865.533-1.196a1.812 1.812 0 0 1 1.28-.497c.497 0 .923.165 1.275.497.353.331.53.731.53 1.196 0 .467-.177.865-.53 1.193Z" style="fill:#157ffb;fill-rule:nonzero;" transform="translate(-1.257 -1.257) scale(1.0582)"></path></svg><p class="custom-container-title">通信</p><p>😤</p></div><p><strong>通信</strong> 是指 <strong>线程之间以何种机制来交换信息</strong>。在命令式编程中，线程间的通信机制有两种：<strong>共享内存</strong> 和 <strong>消息传递</strong>。</p><p>在 <strong>共享内存</strong> 的并发模型中，线程之间访问内存中的变量都是公共的，通过 <strong>读写内存中的公共变量</strong>，即可完成隐式的通信。</p><p>在 <strong>消息传递</strong> 的并发模型中，现在之间没有公共的变量，线程之间必须通过 <strong>发送消息</strong> 来进行显式的通信。</p><div class="custom-container info"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M13 1.188C6.477 1.188 1.188 6.477 1.188 13S6.477 24.813 13 24.813 24.813 19.523 24.813 13c0-6.523-5.29-11.812-11.813-11.812Zm2.459 18.307c-.608.24-1.092.422-1.455.548a3.838 3.838 0 0 1-1.262.189c-.736 0-1.309-.18-1.717-.539a1.74 1.74 0 0 1-.611-1.367c0-.215.015-.435.045-.659a8.23 8.23 0 0 1 .147-.759l.761-2.688c.067-.258.125-.503.171-.731.046-.23.068-.441.068-.633 0-.342-.071-.582-.212-.717-.143-.135-.412-.201-.813-.201-.196 0-.398.029-.605.09-.205.063-.383.12-.529.176l.201-.828c.498-.203.975-.377 1.43-.521a4.225 4.225 0 0 1 1.29-.218c.731 0 1.295.178 1.692.53.395.353.594.812.594 1.376 0 .117-.014.323-.041.617a4.129 4.129 0 0 1-.152.811l-.757 2.68a7.582 7.582 0 0 0-.167.736 3.892 3.892 0 0 0-.073.626c0 .356.079.599.239.728.158.129.435.194.827.194.185 0 .392-.033.626-.097.232-.064.4-.121.506-.17l-.203.827Zm-.134-10.878a1.807 1.807 0 0 1-1.275.492c-.496 0-.924-.164-1.28-.492a1.57 1.57 0 0 1-.533-1.193c0-.465.18-.865.533-1.196a1.812 1.812 0 0 1 1.28-.497c.497 0 .923.165 1.275.497.353.331.53.731.53 1.196 0 .467-.177.865-.53 1.193Z" style="fill:#157ffb;fill-rule:nonzero;" transform="translate(-1.257 -1.257) scale(1.0582)"></path></svg><p class="custom-container-title">同步</p><p>😤</p></div><p><strong>同步</strong> 是指 <strong>程序中用于控制不同线程间操作发生相对顺序的机制</strong>。</p><p>在 <strong>共享内存</strong> 的并发模型中，同步是显式进行的，即在对公共方法、代码块进行操作时，就存在同步问题。程序员必须显式地指定某个方法或代码块需要在线程之间 <strong>互斥的执行</strong>。</p><p>在 <strong>消息传递</strong> 的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式的。</p><div class="custom-container info"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M13 1.188C6.477 1.188 1.188 6.477 1.188 13S6.477 24.813 13 24.813 24.813 19.523 24.813 13c0-6.523-5.29-11.812-11.813-11.812Zm2.459 18.307c-.608.24-1.092.422-1.455.548a3.838 3.838 0 0 1-1.262.189c-.736 0-1.309-.18-1.717-.539a1.74 1.74 0 0 1-.611-1.367c0-.215.015-.435.045-.659a8.23 8.23 0 0 1 .147-.759l.761-2.688c.067-.258.125-.503.171-.731.046-.23.068-.441.068-.633 0-.342-.071-.582-.212-.717-.143-.135-.412-.201-.813-.201-.196 0-.398.029-.605.09-.205.063-.383.12-.529.176l.201-.828c.498-.203.975-.377 1.43-.521a4.225 4.225 0 0 1 1.29-.218c.731 0 1.295.178 1.692.53.395.353.594.812.594 1.376 0 .117-.014.323-.041.617a4.129 4.129 0 0 1-.152.811l-.757 2.68a7.582 7.582 0 0 0-.167.736 3.892 3.892 0 0 0-.073.626c0 .356.079.599.239.728.158.129.435.194.827.194.185 0 .392-.033.626-.097.232-.064.4-.121.506-.17l-.203.827Zm-.134-10.878a1.807 1.807 0 0 1-1.275.492c-.496 0-.924-.164-1.28-.492a1.57 1.57 0 0 1-.533-1.193c0-.465.18-.865.533-1.196a1.812 1.812 0 0 1 1.28-.497c.497 0 .923.165 1.275.497.353.331.53.731.53 1.196 0 .467-.177.865-.53 1.193Z" style="fill:#157ffb;fill-rule:nonzero;" transform="translate(-1.257 -1.257) scale(1.0582)"></path></svg><p class="custom-container-title">Java 中的并发模型</p><p>😤</p></div><p>在 Java 中，并发采用的是 <strong>共享内存</strong> 模型，Java 线程之间的通信总是隐式进行的，整个通信过程对程序员完全透明。</p><p>所以，如果我们不了解多线程之间通信的工作机制，就可能会遇到各种奇怪的内存可见性问题，俗称 Bug。</p><h2 id="_2-java-内存模型是什么" tabindex="-1"><a class="header-anchor" href="#_2-java-内存模型是什么" aria-hidden="true">#</a> 2. Java 内存模型是什么</h2><h3 id="_2-1-jmm-的抽象结构" tabindex="-1"><a class="header-anchor" href="#_2-1-jmm-的抽象结构" aria-hidden="true">#</a> 2.1 JMM 的抽象结构</h3><p>在 Java 中，所有 <strong>实例变量（引用对象）、静态变量和数组元素</strong> 都存储在 <strong>堆</strong> 中，<strong>堆内存在线程之间共享</strong>，我们称这些为 <strong>共享变量</strong>。而局部变量、方法参数等不会在线程之间共享，因此它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 JMM 控制，JMM 决定着 <strong>一个线程对共享变量的写入何时对另一个线程可见</strong>。</p><p>JMM 主要由三部分构成：<strong>1 个主内存、n 个线程、n 个工作内存</strong>，共享数据就在它们三者之间来回倒腾。</p><p>线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。</p><p>本地内存是一个抽象的概念，并不真实存在，JMM 的抽象示意图如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212142156195.png" alt="image-20221214215603328"></p><p>如果线程间要进行通信，则需要通过 Java 给我们提供的 8 个原子操作，过程如下：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212142203111.png" alt="image-20221214220344781"></p><p>从途中可以看出，一个变量从主内存拷贝到工作内存，再从工作内存同步回主内存的流程为：</p><ul><li><code>|主内存| -&gt; read -&gt; load -&gt; |工作内存| -&gt; use -&gt; |Java线程| -&gt; assign -&gt; |工作内存| -&gt; store -&gt; write -&gt; |主内存|</code></li></ul><h3 id="_2-2-jmm-中的-8-个原子操作" tabindex="-1"><a class="header-anchor" href="#_2-2-jmm-中的-8-个原子操作" aria-hidden="true">#</a> 2.2 JMM 中的 8 个原子操作</h3><p>JMM 中的 8 个原子操作含义如下：</p><ul><li><code>lock</code>：作用于主内存，把一个变量标识为一个线程独占状态。</li><li><code>unlock</code>：作用于主内存，释放一个处于锁定状态的变量。</li><li><code>read</code>：作用于主内存，把一个变量的值从主内存传输到线程工作内存中，供之后的 <code>load</code> 操作使用。</li><li><code>load</code>：作用于工作内存，把 <code>read</code> 操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><code>use</code>：作用于工作内存，把工作内存中的一个变量传递给执行引擎，虚拟机遇到使用变量值的字节码指令时会执行。</li><li><code>assign</code>：作用于工作内存，把一个从执行引擎得到的值赋给工作内存的变量，虚拟机遇到给变量赋值的字节码指令时会执行。</li><li><code>store</code>：作用于工作内存，把工作内存中的一个变量传送到主内存中，供之后的 <code>write</code> 操作使用。</li><li><code>write</code>：作用于主内存，把 <code>store</code> 操作从工作内存中得到的变量值存入主内存的变量中。</li></ul><p>这 8 个原子操作有对应的执行规则，分为加锁规则和变量拷贝规则。</p><div class="custom-container info"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M13 1.188C6.477 1.188 1.188 6.477 1.188 13S6.477 24.813 13 24.813 24.813 19.523 24.813 13c0-6.523-5.29-11.812-11.813-11.812Zm2.459 18.307c-.608.24-1.092.422-1.455.548a3.838 3.838 0 0 1-1.262.189c-.736 0-1.309-.18-1.717-.539a1.74 1.74 0 0 1-.611-1.367c0-.215.015-.435.045-.659a8.23 8.23 0 0 1 .147-.759l.761-2.688c.067-.258.125-.503.171-.731.046-.23.068-.441.068-.633 0-.342-.071-.582-.212-.717-.143-.135-.412-.201-.813-.201-.196 0-.398.029-.605.09-.205.063-.383.12-.529.176l.201-.828c.498-.203.975-.377 1.43-.521a4.225 4.225 0 0 1 1.29-.218c.731 0 1.295.178 1.692.53.395.353.594.812.594 1.376 0 .117-.014.323-.041.617a4.129 4.129 0 0 1-.152.811l-.757 2.68a7.582 7.582 0 0 0-.167.736 3.892 3.892 0 0 0-.073.626c0 .356.079.599.239.728.158.129.435.194.827.194.185 0 .392-.033.626-.097.232-.064.4-.121.506-.17l-.203.827Zm-.134-10.878a1.807 1.807 0 0 1-1.275.492c-.496 0-.924-.164-1.28-.492a1.57 1.57 0 0 1-.533-1.193c0-.465.18-.865.533-1.196a1.812 1.812 0 0 1 1.28-.497c.497 0 .923.165 1.275.497.353.331.53.731.53 1.196 0 .467-.177.865-.53 1.193Z" style="fill:#157ffb;fill-rule:nonzero;" transform="translate(-1.257 -1.257) scale(1.0582)"></path></svg><p class="custom-container-title">加锁规则：</p><ul><li>一个变量在 <strong>同一时刻只允许一个线程对其进行 <code>lock</code></strong>，但可以被多次 <code>lock</code>（可重入锁）；</li><li>对一个变量进行 <code>lock</code> 操作会 <strong>清空这个变量在所有工作内存中的值</strong>，然后再使用时，需要通过 <code>assign</code> 或 <code>load</code> 重新对这个变量进行初始化；</li><li>对一个变量进行 <strong><code>lock</code> 前</strong>，必须将 <strong>该变量同步回主内存中</strong>，即执行 <code>store</code> 和 <code>write</code> 操作；</li><li>一个变量没有被 <code>lock</code>，就不能被 <code>unlock</code>，也不能去 <code>unlock</code> 一个被其他线程 <code>lock</code> 的变量；</li></ul></div><div class="custom-container info"><svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M13 1.188C6.477 1.188 1.188 6.477 1.188 13S6.477 24.813 13 24.813 24.813 19.523 24.813 13c0-6.523-5.29-11.812-11.813-11.812Zm2.459 18.307c-.608.24-1.092.422-1.455.548a3.838 3.838 0 0 1-1.262.189c-.736 0-1.309-.18-1.717-.539a1.74 1.74 0 0 1-.611-1.367c0-.215.015-.435.045-.659a8.23 8.23 0 0 1 .147-.759l.761-2.688c.067-.258.125-.503.171-.731.046-.23.068-.441.068-.633 0-.342-.071-.582-.212-.717-.143-.135-.412-.201-.813-.201-.196 0-.398.029-.605.09-.205.063-.383.12-.529.176l.201-.828c.498-.203.975-.377 1.43-.521a4.225 4.225 0 0 1 1.29-.218c.731 0 1.295.178 1.692.53.395.353.594.812.594 1.376 0 .117-.014.323-.041.617a4.129 4.129 0 0 1-.152.811l-.757 2.68a7.582 7.582 0 0 0-.167.736 3.892 3.892 0 0 0-.073.626c0 .356.079.599.239.728.158.129.435.194.827.194.185 0 .392-.033.626-.097.232-.064.4-.121.506-.17l-.203.827Zm-.134-10.878a1.807 1.807 0 0 1-1.275.492c-.496 0-.924-.164-1.28-.492a1.57 1.57 0 0 1-.533-1.193c0-.465.18-.865.533-1.196a1.812 1.812 0 0 1 1.28-.497c.497 0 .923.165 1.275.497.353.331.53.731.53 1.196 0 .467-.177.865-.53 1.193Z" style="fill:#157ffb;fill-rule:nonzero;" transform="translate(-1.257 -1.257) scale(1.0582)"></path></svg><p class="custom-container-title">变量拷贝规则：</p><ul><li><strong>不允许 <code>read</code> 和 <code>load</code>，<code>store</code> 和 <code>write</code> 单独出现</strong>；</li><li>不允许线程丢弃它最近的 <code>assign</code> 操作，即 <strong>工作内存变化后必须同步回主内存</strong>；</li><li>不允许一个线程在没有 <code>assign</code> 的情况下将工作内存同步回主内存中，也就是说虚拟机 <strong>只有遇到变量赋值的字节码时才会将工作内存同步回主内存</strong>；</li><li><strong>新的变量只能从主内存中诞生</strong>，即不能在工作内存中使用未被 <code>load</code> 和 <code>assign</code> 的变量，一个变量在 <code>use</code> 和 <code>store</code> 前一定先经过了 <code>load</code> 和 <code>assign</code></li></ul></div><h3 id="_2-3-可见性、有序性问题" tabindex="-1"><a class="header-anchor" href="#_2-3-可见性、有序性问题" aria-hidden="true">#</a> 2.3 可见性、有序性问题</h3><p>通过上面的图可以发现，<strong>Java 线程只能操作自己的工作内存</strong>，其对变量的所有读写操作，都必须在工作内存中进行，不能直接读写主内存中的变量。所以，可能会 <strong>存在可见性问题</strong>：</p><ul><li>因为对于主内存中的变量 A，其在不同线程的工作内存中可能存在不同的变量副本 A1、A2、A3；</li><li><strong>不同线程间的 <code>read</code> 和 <code>load</code>、<code>store</code> 和 <code>write</code> 不一定是连续执行的，中间可以穿插其他命令</strong>。Java 只能保证它们的执行 <strong>对于一个线程而言是连续的</strong>，但是并不保证不同线程的执行是连续的。</li></ul><p>假设有两个线程 A 和 B，其中线程 A 在写入共享变量，线程 B 要读取共享变量，我们想让线程 A 先完成写入，线程 B 再完成读取，如下图：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212142244245.png" alt="image-20221214224411159"></p><p>此时即便我们是按照 “线程 A 写入 -&gt; 线程 B 读取” 的顺序开始执行的，真实的执行顺序也可能是这样的：<code>storeA -&gt; readB -&gt; writeA -&gt; loadB</code>，这将导致线程 B 读取的是变量的旧值，而非线程 A 修改过的新值。</p><p>也就是说，<strong>线程 A 修改变量的执行先于线程 B 操作了，但这个操作对于线程 B 而言依旧是不可见的</strong>。</p><p>那么如何解决这个问题呢？通过上述的分析可以发现，<strong>可见性问题的本身，也是由于不同线程之间的执行顺序得不到保证导致的</strong>，因此我们也可以将它的解决和有序性合并，即对 Java 一些指令的 <strong>操作顺序进行限制</strong>，这样既保证了有序性，又解决了可见性。</p><p>于是乎，Java 给出了一些命令执行的顺序规范，也就是大名鼎鼎的 <strong>Happens-Before 规则</strong>，后面会讲到。</p><h3 id="_2-4-重排序问题" tabindex="-1"><a class="header-anchor" href="#_2-4-重排序问题" aria-hidden="true">#</a> 2.4 重排序问题</h3><p>在执行程序时，为了 <strong>提高性能</strong>，编译器和处理器常常会 <strong>对指令做重排序</strong>。</p><p>重排序分为三种：</p><ul><li><strong>编译器优化</strong> 的重排序：编译器在不改变单线程程序语义的前提下，可以 <strong>重新安排语句的执行顺序</strong>；</li><li><strong>指令级并行</strong> 的重排序：现代处理器采用了指令级并行技术来 <strong>将多条指令重叠执行</strong>。如果 <strong>不存在数据依赖性</strong>，处理器可以 <strong>改变语句对应机器指令的执行顺序</strong>。</li><li><strong>内存系统</strong> 的重排序：由于处理器使用缓存和读写缓冲区，这使得 <strong>加载和存储操作看上去可能是在乱序执行</strong>。</li></ul><p>所以，从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212142310583.png" alt="image-20221214231026487"></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序可能会导致多线程程序出现 <strong>内存可见性问题</strong>。</p><p>对于编译器，<strong>JMM 的编译器重排序规则会禁止特定类型的编译器重排序</strong>（不是所有的编译器重排序都要禁止）。</p><p>对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的 <strong>内存屏障</strong>（Memory Barriers）指令，<strong>通过内存屏障指令来禁止特定类型的处理器重排序</strong>。</p><p>JMM 属于语言级的内存模型，它确保 <strong>在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证</strong>。</p><h2 id="_3-happens-before-规则" tabindex="-1"><a class="header-anchor" href="#_3-happens-before-规则" aria-hidden="true">#</a> 3. Happens-Before 规则</h2><h3 id="_3-1-什么是-happens-before" tabindex="-1"><a class="header-anchor" href="#_3-1-什么是-happens-before" aria-hidden="true">#</a> 3.1 什么是 Happens-Before</h3><p>在 JMM 中，如果 <strong>一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在 happens-before 关系。这里的两个操作既可以是在一个线程之内，<strong>也可以是在不同线程之间</strong>。因此，<strong>JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证</strong>。</p><p>例如：如果 A 线程的写操作 a 与 B 线程 的读操作 b 之间存在 happens-before 规则，<strong>尽管操作 a 和 操作 b 在不同的线程中执行，但 JMM 也能向程序员保证 a 操作对 b 操作可见</strong>。</p><p><strong>happens-before 规则本质上是一种顺序约束规范，用来约束编译器的优化行为</strong>。也就是说，为了执行效率，我们允许编译器的重排序优化，但是为了保证程序运行的正确性，我们要求编译器优化后需要满足 happens-before 规则。</p><p><strong>与程序员密切相关的 happens-before 规则如下</strong>：</p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。意思就是在一个线程中程序要有序的执行。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before 于随后对这个锁的加锁。意思就是要先释放锁，才能进行加锁。</li><li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。 意思就是写操作执行完之后才能进行读操作，这是 volatile 保证可见性的依据之一。</li><li><strong>传递性</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li></ul><blockquote><p>看完这些 happens-before 规则别懵逼，其实这些规则就是让我们知道我们编写的程序是怎么被运行的。我们只要能通过这些规则，去推断程序的运行结果，编写合理的代码即可。</p></blockquote><p>也就是说，<strong>程序员是基于 happens-before 规则来编程的</strong>，这样程序才不会出错。</p><p>拿监视器锁规则来举例，假设我们不知道「解锁 happens-before 加锁」这条规则，我们在一个程序中没有对锁进行解锁（不知道用完了要解锁），然后在另一个程序中需要对这个锁进行加锁，这样肯定是加锁不成功的。</p><p>happens-before 是 JMM 最核心的概念，理解 happens-before 是理解 JMM 的关键。我们从 JMM 的设计来反观 happens-before。</p><h3 id="_3-2-jmm-的设计" tabindex="-1"><a class="header-anchor" href="#_3-2-jmm-的设计" aria-hidden="true">#</a> 3.2 JMM 的设计</h3><p>从 JMM 设计者的角度看，需要考虑两个关键的因素：</p><ul><li><strong>程序员对内存模型的使用</strong>：程序员希望内存模型易于理解、易于编程；</li><li><strong>编译器和处理器对内存模型的实现</strong>：编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能；</li></ul><p>所以，程序员希望实现一个强内存模型，而编译器和处理器则希望实现一个弱内存模型。</p><p>可以发现，这两者是互相矛盾的，所以，JMM 的设计专家的核心目标就是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性的保证，另一方面，对编译器和处理器的限制要尽可能地放松。</p><p>下面举一个例子，来看看 JMM 设计者是如何实现这个目标地。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>		<span class="token comment">// A</span>
<span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> 	       	<span class="token comment">// B</span>
<span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>      <span class="token comment">// C</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面计算圆的面积地示例代码中，存在 3 个 happens-before 关系：</p><ul><li>A happens-before B；</li><li>B happens-before C；</li><li>A happens-before C；</li></ul><p>在这 3 个 happens-before 关系中，第二、三个是必须地，但是第一个不是。</p><p>因此 JMM 把 happens-before 要求禁止的重排序分为了下面两类：</p><ul><li>会改变程序执行结果的重排序；</li><li>不会改变程序执行结果的重排序；</li></ul><p>JMM 对这两种不同性质的重排序，采取了不同的策略，如下：</p><ul><li>对于 <strong>会改变</strong> 程序执行结果的重排序，JMM 要求编译器和处理器 <strong>必须禁止这种重排序</strong>；</li><li>对于 <strong>不会改变</strong> 程序执行结果的重排序，JMM 对编译器和处理器 <strong>不做要求</strong>（JMM允许这种重排序）。</li></ul><p>下图是 JMM 的设计示意图：</p><p><img src="https://run-notes.oss-cn-beijing.aliyuncs.com/notes/202212152311386.png" alt="image-20221215231105006"></p><p>从上图可以看出，即使是 happens-before 规则要求禁止的重排序，只要不会改变程序执行的结果，JMM 还是允许编辑器和处理器进行重排序优化，以提高性能。</p><h2 id="_4-内存屏障" tabindex="-1"><a class="header-anchor" href="#_4-内存屏障" aria-hidden="true">#</a> 4. 内存屏障</h2><h3 id="_4-1-什么是内存屏障" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是内存屏障" aria-hidden="true">#</a> 4.1 什么是内存屏障</h3><p>内存屏障，又称内存栅栏，是一个 CPU 指令，它可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。</p><p>所以，内存屏障有如下作用：</p><ul><li>保证特定操作的执行顺序，即 <strong>防止重排序</strong>；</li><li>影响某些数据的 <strong>内存可见性</strong>。</li></ul><p>编译器和处理器能够重排序指令，在保证最终结果不变的情况下，通过指令重排来尝试优化性能。插入一条 Memory Barrier 会告诉编译器和处理器：<strong>不管什么指令都不能和这条 Memory Barrier 指令重排序</strong>。</p><p>Memory Barrier 所做的另外一件事是 <strong>强制刷出各种 CPU Cache</strong>，如一个 Write-Barrier（写入屏障）将刷出所有在 Barrier 之前写入 Cache 的数据，因此，任何 CPU 上的线程都能读取到这些数据的最新版本，保证了内存可见性。</p><h3 id="_4-2-jmm-提供的内存屏障" tabindex="-1"><a class="header-anchor" href="#_4-2-jmm-提供的内存屏障" aria-hidden="true">#</a> 4.2 JMM 提供的内存屏障</h3><p>JMM 为了屏蔽底层硬件平台的差异，提供了四类内存屏障指令：</p><table><thead><tr><th>屏障类型</th><th style="text-align:left;">指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td style="text-align:left;">Load1；LoadLoad；Load2</td><td>保证该屏障后第一个读操作（load2）之前，一定先读 load1 对应的数据</td></tr><tr><td>StoreStore</td><td style="text-align:left;">Store1；StoreStore；Store2</td><td>保证该屏障后第一个写操作（store2）之前，store1 写操作对其他处理器可见（已刷到主内存）</td></tr><tr><td>LoadStore</td><td style="text-align:left;">Load1；LoadStore；Store2</td><td>该屏障后第一个写操作（store2）之前，保证 load1 的读操作已经结束</td></tr><tr><td>StoreLoad</td><td style="text-align:left;">Store1；StoreLoad；Load2</td><td>保证 store1 写操作的可见性（已刷到主内存）之后，load2 的读操作才能执行</td></tr></tbody></table><p>内存屏障是 volatile 内存语义实现的重要依据，所以非常重要。</p><h2 id="_5-参考文章" tabindex="-1"><a class="header-anchor" href="#_5-参考文章" aria-hidden="true">#</a> 5. 参考文章</h2><div class="custom-container link"><a class="external-link" href="https://github.com/TangBean/Java-Concurrency-in-Practice" rel="noopener noreferrer" target="_blank"><!--[--><!--]--><!----><span></span><!--[--><!--]--></a><img alt="link-image" src="https://github.com/fluidicon.png" class="custom-container-identifier"><div class="custom-container-title">《Java 并发编程实战》阅读笔记</div><div class="custom-container-description"><p class="custom-container-link-text"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-139.52 -43.52 599.04 599.04" fill="currentColor"><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg> github.com</p><!--[--><!--]--></div></div><div class="custom-container link"><a class="external-link" href="https://book.douban.com/subject/26591326/" rel="noopener noreferrer" target="_blank"><!--[--><!--]--><!----><span></span><!--[--><!--]--></a><img alt="link-image" src="https://img1.doubanio.com/favicon.ico" class="custom-container-identifier"><div class="custom-container-title">《Java 并发编程的艺术》</div><div class="custom-container-description"><p class="custom-container-link-text"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-139.52 -43.52 599.04 599.04" fill="currentColor"><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg> book.douban.com</p><!--[--><!--]--></div></div></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg><a class="external-link meta-item-label" href="https://github.com/AruNi-01/github.AruNi.io/edit/main/posts/2022-12-16-Java 内存模型.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub"><!--[--><!--]--><!----><span>Edit this page on GitHub</span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><div class="pager"><a href="/posts/2022-12-12-%E4%BB%80%E4%B9%88%E6%98%AF%20HTTP.html" class="previous">Previous<br><span>什么是 HTTP</span></a><a href="/posts/2022-12-17-Object%20%E7%B1%BB.html" class="next">Next<br><span>Object 类</span></a></div><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-_1-java-内存模型基础">1. Java 内存模型基础</li><li class="level-3 toc-link-_1-1-为什么需要并发">1.1 为什么需要并发</li><li class="level-3 toc-link-_1-2-并发编程的问题">1.2 并发编程的问题</li><li class="level-2 toc-link-_2-java-内存模型是什么">2. Java 内存模型是什么</li><li class="level-3 toc-link-_2-1-jmm-的抽象结构">2.1 JMM 的抽象结构</li><li class="level-3 toc-link-_2-2-jmm-中的-8-个原子操作">2.2 JMM 中的 8 个原子操作</li><li class="level-3 toc-link-_2-3-可见性、有序性问题">2.3 可见性、有序性问题</li><li class="level-3 toc-link-_2-4-重排序问题">2.4 重排序问题</li><li class="level-2 toc-link-_3-happens-before-规则">3. Happens-Before 规则</li><li class="level-3 toc-link-_3-1-什么是-happens-before">3.1 什么是 Happens-Before</li><li class="level-3 toc-link-_3-2-jmm-的设计">3.2 JMM 的设计</li><li class="level-2 toc-link-_4-内存屏障">4. 内存屏障</li><li class="level-3 toc-link-_4-1-什么是内存屏障">4.1 什么是内存屏障</li><li class="level-3 toc-link-_4-2-jmm-提供的内存屏障">4.2 JMM 提供的内存屏障</li><li class="level-2 toc-link-_5-参考文章">5. 参考文章</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep title | tag ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div title="toggle color mode" class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewbox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
      <a href="https://v2.vuepress.vuejs.org/" target="_blank">VuePress</a> 🤍
      <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
      <br>
      Copyright &copy; 2020-2022 <a href="https://github.com/AruNi-01" target="_blank">AruNi_Lu</a>
    </span></footer></div><!----><!--]--></div>
    <script type="module" src="/assets/app.307f64f3.js" defer></script>
  </body>
</html>
